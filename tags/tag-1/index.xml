<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>tag-1 on Even - A super concise theme for Hugo</title>
    <link>https://cps.shaozhd.com/tags/tag-1/</link>
    <description>Recent content in tag-1 on Even - A super concise theme for Hugo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 31 Aug 2021 01:37:56 +0800</lastBuildDate><atom:link href="https://cps.shaozhd.com/tags/tag-1/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>8.5</title>
      <link>https://cps.shaozhd.com/post/ch08/8.5/8.5/</link>
      <pubDate>Tue, 31 Aug 2021 01:37:56 +0800</pubDate>
      
      <guid>https://cps.shaozhd.com/post/ch08/8.5/8.5/</guid>
      <description>Exercises for Section 8.5 8.5.1 Construct the DAG for the basic block 1 2 3 4 d = b * c e = a + b b = b * c a = e - d answer 8.5.2 Simplify the three-address code of Exercise 8.5.1, assuming Only a is live on exit from the block. a, b, and c are live on exit from the block. answer Only a is</description>
    </item>
    
    <item>
      <title>2.2</title>
      <link>https://cps.shaozhd.com/post/ch02/2.2/2.2/</link>
      <pubDate>Mon, 30 Aug 2021 01:37:56 +0800</pubDate>
      
      <guid>https://cps.shaozhd.com/post/ch02/2.2/2.2/</guid>
      <description>2.2 Exercises for Section 2.2 2.2.1 Consider the context-free grammar: S -&amp;gt; S S + | S S * | a Show how the string aa+a* can be generated by this grammar. Construct a parse tree for this string. What language does this grammar generate? Justify your answer. answer S -&amp;gt; S S * -&amp;gt; S S + S * -&amp;gt; a S + S * -&amp;gt; a a +</description>
    </item>
    
    <item>
      <title>2.3</title>
      <link>https://cps.shaozhd.com/post/ch02/2.3/2.3/</link>
      <pubDate>Mon, 30 Aug 2021 01:37:56 +0800</pubDate>
      
      <guid>https://cps.shaozhd.com/post/ch02/2.3/2.3/</guid>
      <description>2.3 Exercises for Section 2.3 2.3.1 Construct a syntax-directed translation scheme that trans­ lates arithmetic expressions from infix notation into prefix notation in which an operator appears before its operands; e.g. , -xy is the prefix notation for x - y . Give annotated parse trees for the inputs 9-5+2 and 9-5*2.。 answer productions: 1 2 3 4 5</description>
    </item>
    
    <item>
      <title>2.4</title>
      <link>https://cps.shaozhd.com/post/ch02/2.4/2.4/</link>
      <pubDate>Mon, 30 Aug 2021 01:37:56 +0800</pubDate>
      
      <guid>https://cps.shaozhd.com/post/ch02/2.4/2.4/</guid>
      <description>2.4 节的练习 2.4.1 为下列文法构造递归下降语法分析器 S -&amp;gt; + S S | - S S | a S -&amp;gt; S ( S ) S | ε S -&amp;gt; 0 S 1 | 0 1 解答 1） S -&amp;gt; + S S | - S S | a void S(){ switch(lookahead){ case &amp;quot;+&amp;quot;:</description>
    </item>
    
    <item>
      <title>2.6</title>
      <link>https://cps.shaozhd.com/post/ch02/2.6/2.6/</link>
      <pubDate>Mon, 30 Aug 2021 01:37:56 +0800</pubDate>
      
      <guid>https://cps.shaozhd.com/post/ch02/2.6/2.6/</guid>
      <description>2.6 节的练习 2.6.1 扩展 2.6.5 节中的词法分析器以消除注释。注释的定义如下： 以 // 开始的注释，包括从它开始到这一行结尾的呃所有字符 以 /* 开始的注释，包括从它到</description>
    </item>
    
    <item>
      <title>2.8</title>
      <link>https://cps.shaozhd.com/post/ch02/2.8/2.8/</link>
      <pubDate>Mon, 30 Aug 2021 01:37:56 +0800</pubDate>
      
      <guid>https://cps.shaozhd.com/post/ch02/2.8/2.8/</guid>
      <description>2.8 节的练习 2.8.1 C 语言和 JAVA 语言中的 for 语句具有如下形式： for(expr1; expr2; expr3) stmt 第一个表达式在循环之前执行，它通常被用来初始化循环下标。第二个表达式是一个测试，它</description>
    </item>
    
    <item>
      <title>2.key-point</title>
      <link>https://cps.shaozhd.com/post/ch02/key-point/key-point/</link>
      <pubDate>Mon, 30 Aug 2021 01:37:56 +0800</pubDate>
      
      <guid>https://cps.shaozhd.com/post/ch02/key-point/key-point/</guid>
      <description>第2章要点 1. 文法、语法制导翻译方案、语法制导的翻译器 以一个仅支持个位数加减法的表达式为例 文法 list -&amp;gt; list + digit | list - digit | digit digit -&amp;gt; 0 | 1 | … | 9 （消除了</description>
    </item>
    
    <item>
      <title>3.1</title>
      <link>https://cps.shaozhd.com/post/ch03/3.1/3.1/</link>
      <pubDate>Mon, 30 Aug 2021 01:37:56 +0800</pubDate>
      
      <guid>https://cps.shaozhd.com/post/ch03/3.1/3.1/</guid>
      <description>3.1 节的练习 3.1.1 将下面 C++ 程序： float limitedSquare(x){float x; /* returns x-squared, nut never more than 100 */ return (x &amp;lt;= -10.0 || x &amp;gt;= 10.0) ? 100 : x*x; } 划分成正确的词素序列。哪些词素应该有关联的语法值？应该具有什么值</description>
    </item>
    
    <item>
      <title>3.3</title>
      <link>https://cps.shaozhd.com/post/ch03/3.3/3.3/</link>
      <pubDate>Mon, 30 Aug 2021 01:37:56 +0800</pubDate>
      
      <guid>https://cps.shaozhd.com/post/ch03/3.3/3.3/</guid>
      <description>3.3 节的练习 3.3.1 对于下列各个语言 C C++ C# Fortran Java Lisp SQL 查询语言使用手册以确定： 形成各语言的输入字母表的字符集分别是什么（不包括哪些只能出现在字符串或注释</description>
    </item>
    
    <item>
      <title>3.4</title>
      <link>https://cps.shaozhd.com/post/ch03/3.4/3.4/</link>
      <pubDate>Mon, 30 Aug 2021 01:37:56 +0800</pubDate>
      
      <guid>https://cps.shaozhd.com/post/ch03/3.4/3.4/</guid>
      <description>3.4 节的练习 3.4.1 给出识别练习 3.3.2 中各个正则表达式所描述的语言状态转换图。 解答 解答步骤：NFA -&amp;gt; DFA -&amp;gt; 最少状态的 DFA（状态转换图） a(a|b)*a NFA: DFA: NFA DFA a b {0} A</description>
    </item>
    
    <item>
      <title>3.5</title>
      <link>https://cps.shaozhd.com/post/ch03/3.5/3.5/</link>
      <pubDate>Mon, 30 Aug 2021 01:37:56 +0800</pubDate>
      
      <guid>https://cps.shaozhd.com/post/ch03/3.5/3.5/</guid>
      <description>3.5 节的练习 3.5.1 描述如何对图 3-23 中的 Lex 程序做出如下修改： 增加关键字 while 将比较运算符转换成 C 语言中的同类运算符 允许把下划线当做一个附加的字母 ！ 增加一个</description>
    </item>
    
    <item>
      <title>3.6</title>
      <link>https://cps.shaozhd.com/post/ch03/3.6/3.6/</link>
      <pubDate>Mon, 30 Aug 2021 01:37:56 +0800</pubDate>
      
      <guid>https://cps.shaozhd.com/post/ch03/3.6/3.6/</guid>
      <description>3.6 节的练习 3.6.1 ！ 3.4 节的练习中图 3-19 计算了 KMP 算法的失效函数。说明在已知失效函数的情况下，如何根据已知的关键字 b_1b_2…b_n 构造出一个具有 n+1 个</description>
    </item>
    
    <item>
      <title>3.7</title>
      <link>https://cps.shaozhd.com/post/ch03/3.7/3.7/</link>
      <pubDate>Mon, 30 Aug 2021 01:37:56 +0800</pubDate>
      
      <guid>https://cps.shaozhd.com/post/ch03/3.7/3.7/</guid>
      <description>3.7 节的练习 3.7.1 将下图中的 NFA 转换成 DFA. 解答 1、 转换表 NFA状态 DFA状态 a b {0,1,3} A B C {2} B B ∅ {4} C ∅ C DFA 2、 转换表 NFA状态 DFA状态 a b {0} A B A {0,1}</description>
    </item>
    
    <item>
      <title>3.8</title>
      <link>https://cps.shaozhd.com/post/ch03/3.8/3.8/</link>
      <pubDate>Mon, 30 Aug 2021 01:37:56 +0800</pubDate>
      
      <guid>https://cps.shaozhd.com/post/ch03/3.8/3.8/</guid>
      <description>3.8 节的练习 3.8.1 假设我们有两个词法单元：（1）关键字 if，（2）标识符，它表示除了 if 之外的所有由字母组成的串。请给出： 识别这些词法单元的 NFA 识别这</description>
    </item>
    
    <item>
      <title>3.9</title>
      <link>https://cps.shaozhd.com/post/ch03/3.9/3.9/</link>
      <pubDate>Mon, 30 Aug 2021 01:37:56 +0800</pubDate>
      
      <guid>https://cps.shaozhd.com/post/ch03/3.9/3.9/</guid>
      <description>3.9 节的练习 3.9.1 扩展图 3-58 中的表，使得它包含如下运算符： ？ 解答 节点n nullable(n) firstpos(n) n = c_1 ? true firstpos(c_1) n = c_1 + nullable(c_1) firstpos(c_1) 3.9.2 使用算法 3.26 将练习 3.7.3 中的正则表达式直接转换成 DFA</description>
    </item>
    
    <item>
      <title>3.key-point</title>
      <link>https://cps.shaozhd.com/post/ch03/key-point/key-point/</link>
      <pubDate>Mon, 30 Aug 2021 01:37:56 +0800</pubDate>
      
      <guid>https://cps.shaozhd.com/post/ch03/key-point/key-point/</guid>
      <description>第3章要点 1. 从 NFA、DFA 到正则表达式的转换 http://courses.engr.illinois.edu/cs373/sp2009/lectures/lect_08.pdf 2. KMP 及其扩展算法(p87) 参考 matrix 的博文 KMP算法详解。文中提供了例子，比较容易理解。 3. 字符串</description>
    </item>
    
    <item>
      <title>4.2</title>
      <link>https://cps.shaozhd.com/post/ch04/4.2/4.2/</link>
      <pubDate>Mon, 30 Aug 2021 01:37:56 +0800</pubDate>
      
      <guid>https://cps.shaozhd.com/post/ch04/4.2/4.2/</guid>
      <description>4.2 节的练习 4.2.1 考虑上下文无关文法： S -&amp;gt; S S + | S S * | a 以及串 aa+a* 。 给出这个串的一个最左推导 给出这个串的一个最右推导 给出这个串的一个语法分析树 ！</description>
    </item>
    
    <item>
      <title>4.3</title>
      <link>https://cps.shaozhd.com/post/ch04/4.3/4.3/</link>
      <pubDate>Mon, 30 Aug 2021 01:37:56 +0800</pubDate>
      
      <guid>https://cps.shaozhd.com/post/ch04/4.3/4.3/</guid>
      <description>4.3 节的练习 4.3.1 下面是一个只包含符号 a 和 b 的正则表达式文法。它使用 + 替代表示并运算的字符 | ，以避免和文法中作为元符号使用的竖线相混淆： rexpr -&amp;gt; rexpr + rterm</description>
    </item>
    
    <item>
      <title>4.4</title>
      <link>https://cps.shaozhd.com/post/ch04/4.4/4.4/</link>
      <pubDate>Mon, 30 Aug 2021 01:37:56 +0800</pubDate>
      
      <guid>https://cps.shaozhd.com/post/ch04/4.4/4.4/</guid>
      <description>4.4 节的练习 4.4.1 为下面的每个文法设计一个预测分析器，并给出预测分析表。你可能先要对文法进行提取左公因子或者消除左递归的操作。 练习 4.2.2 中 1 - 7 中的文</description>
    </item>
    
    <item>
      <title>4.5</title>
      <link>https://cps.shaozhd.com/post/ch04/4.5/4.5/</link>
      <pubDate>Mon, 30 Aug 2021 01:37:56 +0800</pubDate>
      
      <guid>https://cps.shaozhd.com/post/ch04/4.5/4.5/</guid>
      <description>4.5 节的练习 4.5.1 对于练习 4.2.2（a）中的文法 S -&amp;gt; 0 S 1 | 0 1，指出下面各个最右句型的句柄。 000111 00S11 解答 01 0S1 4.5.2 对于练习 4.2.1 的文法 S -&amp;gt; S S + | S S * |</description>
    </item>
    
    <item>
      <title>4.6</title>
      <link>https://cps.shaozhd.com/post/ch04/4.6/4.6/</link>
      <pubDate>Mon, 30 Aug 2021 01:37:56 +0800</pubDate>
      
      <guid>https://cps.shaozhd.com/post/ch04/4.6/4.6/</guid>
      <description>4.6 节的练习 4.6.1 描述下列文法的所有可行前缀 练习4.2.2-1的文法 S-&amp;gt;0S1|01 ！ 练习4.2.1的文法 S-&amp;gt;SS+|SS*|a ！ 练习4.2.2-3的文法 S-&amp;gt;S(S)S|ε</description>
    </item>
    
    <item>
      <title>4.7</title>
      <link>https://cps.shaozhd.com/post/ch04/4.7/4.7/</link>
      <pubDate>Mon, 30 Aug 2021 01:37:56 +0800</pubDate>
      
      <guid>https://cps.shaozhd.com/post/ch04/4.7/4.7/</guid>
      <description>4.7 节的练习 4.7.1 为练习 4.2.1 的文法 S -&amp;gt; S S + | S S * | a 构造 规范 LR 项集族 LALR 项集族 4.7.2 对练习 4.2.2-1 ~ 4.4.2-7 的各个文法重复练习 4.7.1 ! 4.7.3 对练习 4.7.1 的文法，使用算法 4.6</description>
    </item>
    
    <item>
      <title>4.key-point</title>
      <link>https://cps.shaozhd.com/post/ch04/key-point/key-point/</link>
      <pubDate>Mon, 30 Aug 2021 01:37:56 +0800</pubDate>
      
      <guid>https://cps.shaozhd.com/post/ch04/key-point/key-point/</guid>
      <description>第4章要点 ！LR(0), SLR, LR, LALR 之间的区别 p157: LR(0) 自动机是如何做出移入-规约决定的？假设文法符号串 γ 使得 LR(0) 自动机从开始状态 0 运行到某个状态 j，那么</description>
    </item>
    
    <item>
      <title>5.1</title>
      <link>https://cps.shaozhd.com/post/ch05/5.1/5.1/</link>
      <pubDate>Mon, 30 Aug 2021 01:37:56 +0800</pubDate>
      
      <guid>https://cps.shaozhd.com/post/ch05/5.1/5.1/</guid>
      <description>5.1 节的练习 5.1.1 对于图 5-1 中的 SDD，给出下列表达式对应的注释语法分析树 (3+4)*(5+6)n 1*2*3*(4+5)n (9+8*(7+6)+5)*4n 解答 (3+4)*(5+6)n 1*2*3*(4+5)n 5.1.2 扩展图 5-4 中的 SDD，使它可以像图 5-1 所示的那样处理表达式 解答</description>
    </item>
    
    <item>
      <title>5.2</title>
      <link>https://cps.shaozhd.com/post/ch05/5.2/5.2/</link>
      <pubDate>Mon, 30 Aug 2021 01:37:56 +0800</pubDate>
      
      <guid>https://cps.shaozhd.com/post/ch05/5.2/5.2/</guid>
      <description>5.2 节的练习 5.2.1 图 5-7 中的依赖图的全部拓扑顺序有哪些 解答 [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ], [ 1, 2, 3, 5, 4, 6, 7, 8, 9 ], [ 1, 2, 4, 3, 5, 6, 7, 8, 9 ], [ 1, 3, 2, 4, 5, 6, 7, 8, 9 ], [</description>
    </item>
    
    <item>
      <title>5.3</title>
      <link>https://cps.shaozhd.com/post/ch05/5.3/5.3/</link>
      <pubDate>Mon, 30 Aug 2021 01:37:56 +0800</pubDate>
      
      <guid>https://cps.shaozhd.com/post/ch05/5.3/5.3/</guid>
      <description>5.3 节的练习 5.3.1 下面是涉及运算符 + 和整数或浮点运算分量的表达式的文法。区分浮点数的方法是看它有无小数点。 E -&amp;gt; E + T | T T -&amp;gt; num.num | num 给出一个 SDD 来确定</description>
    </item>
    
    <item>
      <title>5.4</title>
      <link>https://cps.shaozhd.com/post/ch05/5.4/5.4/</link>
      <pubDate>Mon, 30 Aug 2021 01:37:56 +0800</pubDate>
      
      <guid>https://cps.shaozhd.com/post/ch05/5.4/5.4/</guid>
      <description>5.4 节的练习 5.4.1 我们在 5.4.2 节中提到可能根据语法分析栈中的 LR 状态来推导出这个状态表示了什么文法符号。我们如何推导这个信息？ 解答 见算法 4.44 5.4.2 改写下面的 SDT:</description>
    </item>
    
    <item>
      <title>5.5</title>
      <link>https://cps.shaozhd.com/post/ch05/5.5/5.5/</link>
      <pubDate>Mon, 30 Aug 2021 01:37:56 +0800</pubDate>
      
      <guid>https://cps.shaozhd.com/post/ch05/5.5/5.5/</guid>
      <description>5.5 节的练习 5.5.1 按照 5.5.1 节的风格，将练习 5.4.4 中得到的每个 SDD 实现为递归下降的语法分析器。 5.5.2 按照 5.5.2 节的风格，将练习 5.4.4 中得到的每个 SDD 实现为递归下降的语法分</description>
    </item>
    
    <item>
      <title>6.1</title>
      <link>https://cps.shaozhd.com/post/ch06/6.1/6.1/</link>
      <pubDate>Mon, 30 Aug 2021 01:37:56 +0800</pubDate>
      
      <guid>https://cps.shaozhd.com/post/ch06/6.1/6.1/</guid>
      <description>6.1 节的练习 为下面的表达式构造 DAG ((x+y)-((x+y)*(x-y)))+((x+y)*(x-y)) 解答 为下列表达式构造 DAG，且指出他们每个子表达式的值编码。假定 + 是左结合的。 a+b+(a+b) a+b+a+b a+a+(a+a+a+(a+a+a+a)) 解答 a+b+(a+b) 1 id a 2 id b 3 + 1</description>
    </item>
    
    <item>
      <title>6.2</title>
      <link>https://cps.shaozhd.com/post/ch06/6.2/6.2/</link>
      <pubDate>Mon, 30 Aug 2021 01:37:56 +0800</pubDate>
      
      <guid>https://cps.shaozhd.com/post/ch06/6.2/6.2/</guid>
      <description>6.2 节的练习 6.2.1 将算数表达式 a+-(b+c) 翻译成 抽象语法树 四元式序列 三元式序列 间接三元式序列 解答 抽象语法树 四元式序列 op arg1 arg2 result 0 + b c t1 1 minus t1 t2 2 + a t2 t3 三元</description>
    </item>
    
    <item>
      <title>6.3</title>
      <link>https://cps.shaozhd.com/post/ch06/6.3/6.3/</link>
      <pubDate>Mon, 30 Aug 2021 01:37:56 +0800</pubDate>
      
      <guid>https://cps.shaozhd.com/post/ch06/6.3/6.3/</guid>
      <description>6.3 节的练习 6.3.1 确定下列声明序列中各个标识符的类型和相对地址。 float x; record {float x; float y;} p; record {int tag; float x; float y;} q; 解答 SDT S -&amp;gt; {top = new Evn(); offset = 0;} D D -&amp;gt; T id; {top.put(id.lexeme, T.type, offset); offset += T.width} D1 D</description>
    </item>
    
    <item>
      <title>6.4</title>
      <link>https://cps.shaozhd.com/post/ch06/6.4/6.4/</link>
      <pubDate>Mon, 30 Aug 2021 01:37:56 +0800</pubDate>
      
      <guid>https://cps.shaozhd.com/post/ch06/6.4/6.4/</guid>
      <description>6.4 节的练习 6.4.1 向图 6-19 的翻译方案中加入对应于下列产生式的规则： E -&amp;gt; E1 * E2 E -&amp;gt; +E1 解答 产生式 语义规则 E -&amp;gt; E1 * E2 { E.addr = new Temp(); E.code = E1.code || E2.code || gen(E.addr &#39;=&#39; E1.addr &#39;*&#39; E2.addr); } | +E1</description>
    </item>
    
    <item>
      <title>6.5</title>
      <link>https://cps.shaozhd.com/post/ch06/6.5/6.5/</link>
      <pubDate>Mon, 30 Aug 2021 01:37:56 +0800</pubDate>
      
      <guid>https://cps.shaozhd.com/post/ch06/6.5/6.5/</guid>
      <description>6.5 节的练习 6.5.1 假定图 6-26 中的函数 widen 可以处理图 6-25a 的层次结构中的所有类型，翻译下列表达式。假定 c 和 d 是字符类型，s 和 t 是短整型， i 和 j 为整型， x 是浮</description>
    </item>
    
    <item>
      <title>6.6</title>
      <link>https://cps.shaozhd.com/post/ch06/6.6/6.6/</link>
      <pubDate>Mon, 30 Aug 2021 01:37:56 +0800</pubDate>
      
      <guid>https://cps.shaozhd.com/post/ch06/6.6/6.6/</guid>
      <description>6.6 节的练习 6.6.1 在图 6-36 的语法制导定义中添加处理下列控制流构造的规则： 一个 repeat 语句：repeat S while B ！一个 for 循环语句：for (S1; B; S2) S3 解答 Production Syntax Rule S -&amp;gt;</description>
    </item>
    
    <item>
      <title>6.7</title>
      <link>https://cps.shaozhd.com/post/ch06/6.7/6.7/</link>
      <pubDate>Mon, 30 Aug 2021 01:37:56 +0800</pubDate>
      
      <guid>https://cps.shaozhd.com/post/ch06/6.7/6.7/</guid>
      <description>6.7 节的练习 6.7.1 使用图 6-43 中的翻译方案翻译下列表达式。给出每个子表达式的 truelist 和 falselist。你可以假设第一条被生成的指令的地址是 100. a==b &amp;amp;&amp;amp; (c==d || e==f) (a==b</description>
    </item>
    
    <item>
      <title>7.2</title>
      <link>https://cps.shaozhd.com/post/ch07/7.2/7.2/</link>
      <pubDate>Mon, 30 Aug 2021 01:37:56 +0800</pubDate>
      
      <guid>https://cps.shaozhd.com/post/ch07/7.2/7.2/</guid>
      <description>Exercises for Section 7.2 7.2.1 Suppose that the program of Fig.7.2 uses a partition function that always picks a[m] as the separator v. Also, when the array a[m], … , a[n] is reordered, assume that the order is preserved as much as possible. That is, first come all the elements less than v, in their original order, then all elements equal to v, and finally all elements greater than v,</description>
    </item>
    
    <item>
      <title>7.3</title>
      <link>https://cps.shaozhd.com/post/ch07/7.3/7.3/</link>
      <pubDate>Mon, 30 Aug 2021 01:37:56 +0800</pubDate>
      
      <guid>https://cps.shaozhd.com/post/ch07/7.3/7.3/</guid>
      <description>Exercises for Section 7.3 7.3.1 In Fig. 7.15 is a ML function main that computes Fibonacci numbers in a nonstandard way. Function fibO will compute the nth Fibonacci number for any n &amp;gt;= O. Nested within in is fib1, which computes the nth Fibonacci number on the assumption n &amp;gt;= 2, and nested within fib1 is fib2, which assumes n &amp;gt;= 4. Note that neither fib1 nor fib2 need to</description>
    </item>
    
    <item>
      <title>7.4</title>
      <link>https://cps.shaozhd.com/post/ch07/7.4/7.4/</link>
      <pubDate>Mon, 30 Aug 2021 01:37:56 +0800</pubDate>
      
      <guid>https://cps.shaozhd.com/post/ch07/7.4/7.4/</guid>
      <description>Exercises for Section 7.4 7.4.1 Suppose the heap consists of seven chunks, starting at address 0. The sizes of the chunks, in order, are 80, 30, 60, 50, 70, 20, 40 bytes. When we place an object in a chunk, we put it at the high end if there is enough space remaining to form a smaller chunk (so that the smaller chunk can easily remain on the linked list</description>
    </item>
    
    <item>
      <title>7.5</title>
      <link>https://cps.shaozhd.com/post/ch07/7.5/7.5/</link>
      <pubDate>Mon, 30 Aug 2021 01:37:56 +0800</pubDate>
      
      <guid>https://cps.shaozhd.com/post/ch07/7.5/7.5/</guid>
      <description>Exercises for Section 7.5 7.5.1 What happens to the reference counts of the objects in Fig. 7.19 if: The pointer from A to B is deleted. The pointer from X to A is deleted. The node C is deleted. Figure 7.19: A network of objects answer The pointer from A to B is deleted. The pointer from X to A is deleted. The node C is deleted. 7.5.2 What happens</description>
    </item>
    
    <item>
      <title>7.6</title>
      <link>https://cps.shaozhd.com/post/ch07/7.6/7.6/</link>
      <pubDate>Mon, 30 Aug 2021 01:37:56 +0800</pubDate>
      
      <guid>https://cps.shaozhd.com/post/ch07/7.6/7.6/</guid>
      <description>Exercises for Section 7.6 7.6.1 Show the steps of a mark-and-sweep garbage collector on Fig. 7.19 with the pointer A to B deleted. Fig. 7.19 with the pointer A to C deleted. Fig. 7.20 with the pointer A to D deleted. Fig. 7.20 with the object B deleted. answer Fig. 7.19 with the pointer A to B deleted. before: A.reached = … = I.reached = 0 Unscanned = [] line1:</description>
    </item>
    
    <item>
      <title>7.7</title>
      <link>https://cps.shaozhd.com/post/ch07/7.7/7.7/</link>
      <pubDate>Mon, 30 Aug 2021 01:37:56 +0800</pubDate>
      
      <guid>https://cps.shaozhd.com/post/ch07/7.7/7.7/</guid>
      <description>Exercises for Section 7.7 7.7.1 Suppose that the network of objects from Fig.7.20 is managed by an incremental algorithm that uses the four lists Unreached, Unscanned, Scanned, and Free, as in Baker&amp;rsquo;s algorithm. To be specific, the Unscanned list is managed as a queue, and when more than one object is to be placed on this list due to the scanning of one object, we do so in alphabetical order.</description>
    </item>
    
    <item>
      <title>8.2</title>
      <link>https://cps.shaozhd.com/post/ch08/8.2/8.2/</link>
      <pubDate>Mon, 30 Aug 2021 01:37:56 +0800</pubDate>
      
      <guid>https://cps.shaozhd.com/post/ch08/8.2/8.2/</guid>
      <description>Exercises for Section 8.2 8.2.1 Generate code for the following three-address statements assuming all variables are stored in memory locations. x = 1 x = a x = a + 1 x = a + b The two statements x = b * c y = a + x answer 1. LD R1, #1 ST x, R1 2. LD R1, a ST x, R1 3. LD R1, a ADD R1,</description>
    </item>
    
    <item>
      <title>8.3</title>
      <link>https://cps.shaozhd.com/post/ch08/8.3/8.3/</link>
      <pubDate>Mon, 30 Aug 2021 01:37:56 +0800</pubDate>
      
      <guid>https://cps.shaozhd.com/post/ch08/8.3/8.3/</guid>
      <description>Exercises for Section 8.3 8.3.1 Generate code for the following three-address statements as­ suming stack allocation where register SP points to the top of the stack. 1 2 3 4 5 6 call p call q return call r return return answer 1 2 3 4 5 6 7 8 9 10 100: LD SP, #stackStart 108： ADD SP, SP, #psize 116: ST *SP, #132</description>
    </item>
    
    <item>
      <title>8.4</title>
      <link>https://cps.shaozhd.com/post/ch08/8.4/8.4/</link>
      <pubDate>Mon, 30 Aug 2021 01:37:56 +0800</pubDate>
      
      <guid>https://cps.shaozhd.com/post/ch08/8.4/8.4/</guid>
      <description>Exercises for Section 8.4 8.4.1 Figure 8.10 is a simple matrix-multiplication program. Translate the program into three-address statements of the type we have been using in this section. Assume the matrix entries are numbers that require 8 bytes, and that matrices are stored in row-major order. Construct the flow graph for your code from (a). Identify the loops in your flow graph from (b). 1 2 3 4 5 6</description>
    </item>
    
    <item>
      <title>[中文] 《长恨歌》</title>
      <link>https://cps.shaozhd.com/post/chinese-preview/</link>
      <pubDate>Wed, 30 Aug 2017 01:37:56 +0800</pubDate>
      
      <guid>https://cps.shaozhd.com/post/chinese-preview/</guid>
      <description>《长恨歌》是中国唐朝诗人白居易的一首长篇叙事诗。 第一段：贵妃受宠爱 汉皇重色思倾国，御宇多年求不得。杨家有女初长成，养在深闺人未识。 天生丽质难</description>
    </item>
    
  </channel>
</rss>
